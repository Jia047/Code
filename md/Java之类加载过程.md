[toc]

### 类加载的过程
> 一个类，从加载到内存中开始，到使用，到卸载出内存，其生命周期大致分为一下五部分。
> 加载->验证->准备->解析->初始化

#### 加载
在加载阶段，虚拟机需要完成以下三件事
1. 通过类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流中所代表的静态存储结构转化为方法区中的运行时数据结构。
3. 在内存中生成一个代表该类的Class对象，作为方法区这个类的各种数据的访问入口。
> 就是我们平时使用反射时经常要用的那个Class，对于HotSpot虚拟机，这个类的实例**不在堆中，而在方法区中。**

关于第一点，虚拟机并没有具体要求该二进制字节流去哪里获取、怎么获取，所以就出现了很多种获取二进制字节流的方法。如
1. 从zip,jar, ear, war包获取。
2. 从网络中获取，如applet。
3. 运行时计算生成，如动态代理。
4. 其他文件生成，如jsp。
5. 从数据库中读取。

> 前面已经说过，对于Class文件，并**没有要求一定是要Java源码编译**过来的，也可以从其他途径得来。这就产生了一个问题，如果是虚拟机自己编译的，那么，**遇到很多编译时期的错误时，虚拟机是可以拒绝编译的**。但是，对于从别处来的Class文件，我们不敢肯定其中有没有包含恶意代码，我们也没编译过它，它是否包含编译时的错误，我么无从得知。虚拟机有可能因为载入了恶意二进制字节流，导致系统崩溃。因此，我们需要**对二进制字节流进行验证**。


#### 验证
这一阶段的目的是为了**保护虚拟机**，确保读入的Class文件的字节流包含的信息符合虚拟机的要求，不会危害虚拟机自身的安全。（避免虚拟机跑着跑着就挂了@_@）
> 这一部分内容涉及到Class文件的格式的知识。
大致会验证哪些方面的内容呢？
1. 文件格式验证，验证字节流是否符合Class文件格式规范
    - 是否以魔数 0xCAFEBABE 开头。
    - 主次版本号是否在当前虚拟机的处理范围之内。
    - 常量池的常量中是否有不被支持的常量类型（检测常量tag标志）
2. 元数据验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。
    - 这个类是否有父类（除了java.lang.Object）。
    - 这个类是否继承了不能继承的类（被 final 修饰的类，如String）
    - 如果这个类不是抽象类，那么它是否实现了其父类或接口中所有要求实现的方法。
    - 类中的字段、方法是否与父类产生矛盾（如覆盖了父类的**final字段**，或出现不符合规则的**方法重载**，如方法签名一样，但返回值不一样）
3. 字节码验证，这个阶段将对类的**方法体**做校验分析。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证，主要目的是确保解析动作能正常执行。
> 验证阶段非常重要，但不是一定必要的。如果我们一段代码，已经被验证过，或者我们**能保证其是安全的**，我们就可以**通过 -Xverify:none 参数来关闭验证，以缩短虚拟机加载的时间。**

#### 准备
准备阶段开始**为类变量分配内存并设置和该类变量的初始值**。
- 类变量：被**static**修饰的变量，是**属于类**的，而不是属于某一个类的实例对象。
- 初始值：这里的初始值，是指该变量的数据类型的**零值**。看下表

|数据类型|零值|数据类型|零值|
| ----  | ---      | -------   | ----- |
| int   | 0        | boolean   | false |
| long  | 0L       | float     | 0.0f  |
| short | (short)0 | double    | 0.0d  |
| char  | '\u0000' | reference | null  |
| byte  | (byte)0  |           |       |

给类变量赋予**指定值**是要**等到初始化阶段**才执行的。如下面的语句，在准备阶段，虚拟机给i分配内存并赋 **int** 的零值，即 i=0，然后要等到初始化阶段，i 才被赋 123，即 i=123 。
```java
public static int i = 123;
```
**然鹅**，对于ConstantValue属性的字段（我理解为常量），会在准备阶段时就赋予指定值。如下面这句代码，在准备阶段，虚拟机就给 i 分配了内存，并赋予指定值 123。因为在**编译阶段**，javac 就为 i 生成了ConstantValue属性，然后，在准备阶段，虚拟机根据ConstantValue将 i 赋值为 123 。
```java
public static final int i = 123
```

> ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。
> 在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。

#### 解析
解析阶段是将常量池内的符号引用替换为直接引用的过程。
- 符号引用：一组符号，用来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
- 直接引用：直接引用可以是直接指向目标的指针、相对便宜量或是一个能间接定义到目标的句柄。**直接引用与虚拟机的内存布局有关**。同一个符号引用，在不同的虚拟机中，转化出来的直接引用一般不同。**如果有了直接引用，那引用的目标一定已经在内存中了。**
> 个人理解：
> 符号引用就是一个类引用了其他类，但是虚拟机在并不知道这些类在内存中的何处，所以用符号来说明**我这个类需要这个辅助类**。**等到了解析阶段**，虚拟机知道这些辅助类在内存的何处时，就把**这些符号代替成辅助类的内存地址**，这些地址就是直接引用。

> 回顾前文，**在准备阶段，虚拟机为类变量分配了内存，并设置了零值。我们说，一般要等到初始化阶段才会给变量赋予指定值**。那么在初始化阶段，虚拟机是怎样设置指定值得呢？

#### 初始化
在初始化阶段，**虚拟机根据开发者制定的主观计划初始化变量和其他资源**。（就是我们写的初始化代码）

在这个阶段，有一个叫**类构造器&lt;clinit&gt;()方法**的东西，**初始化其实就是执行这个方法的过程**。下面我们来讲讲这个方法怎么生成的，以及它有什么特点。
##### 类构造器&lt;clinit&gt;()方法的生成
- &lt;clinit&gt;()方法是**编译器自动收集类中的所有的类变量的赋值动作和静态语句块的语句合并生成的**。在该方法中，语句的顺序的前后取决于源代码中的顺序。如源代码中语句a在语句b前，那么在&lt;clinit&gt;()方法中自然是先执行a再执行b。
> - 当时看到这里，我才明白。为什么平时写的静态语句块，我没调用它，程序运行时也会执行这段代码，原来是在加载类的时候执行了。
> - 另外，对于静态语句块，我们可以在其中**访问定义在静态语句块之前的变量**，但是定义在静态语句块之后的变量，我们只能修改，不能访问。
以下面的代码为例，看注释
```java
public class StaticInit{
    // 没进语句块之前，此时 i = 0 （零值）
    static {
        // 对于这一句，i 被修改为 100。
        i = 100;
        // 编译器在这里会报错：“非法前向引用”
        System.out.println(i);
    }

    // 不论前面的代码将 i 更改为多少，等到了这一句， i 都会变成20
    // 换句话说就是前面的修改是无意义的，因此可以随便修改。
    public static int i = 20;
}
```
##### &lt;clinit&gt;()方法特点
- &lt;clinit&gt;()方法与类的构造函数不同。虚拟机会保证子类的&lt;clinit&gt;()方法执行之前，其父类的&lt;clinit&gt;()方法已经执行。
> 因此**虚拟机执行的第一个&lt;clinit&gt;()方法是java.lang.Object的**。
- 由于父类的&lt;clinit&gt;()方法先于子类的&lt;clinit&gt;()方法执行执行，所以**父类的静态语句块要优于子类执行**。
- 如果一个类没有静态语句块，那么可以不为这个类生成&lt;clinit&gt;()方法。（想一下生成&lt;clinit&gt;()方法是用来做什么的。）
- 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境下被正确加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的&lt;clinit&gt;()方法，其它线程只能阻塞，知道执行&lt;clinit&gt;()方法的线程执行完毕。
