### 简介

- 存在于内存的中的数据库 --> 读写速度快。
- 应用于缓存方向、分布式锁。

- 支持：事务、持久化、LUA脚本、LRU驱动时间、多种集群方案

### 特点

- 高性能：将用户经常访问的热点数据置于redis中。下次请求直接在缓存（内存）中查找数据，避免去数据库（硬盘）中获取，从而提高查询速度。在数据库数据更改时，同步改变缓存中的数据即可（删除掉缓存中的数据）。

  >先删除缓存还是先删除数据库中的数据？（缓存一致性问题）
  >
  >

- 高并发：由于将热点数据存于缓存（内存）中，这样操作起来速度更快，占用的资源更少（跟直接去数据库查数据相比），服务器能承受的请求更大，支持更大的并发量。

### 分类

#### 本地缓存：

- map，guava。
- 轻量快速，生命周期随jvm的销毁而结束。
- 可以由多个实例，缓存不存在一致性。

#### 分布式缓存：

- redis，memcached。
- 多个实例共用一份缓存，缓存具有一致性。
- 为了保持缓存的高可用，程序架构较为复杂。

#### Redis 的内存模型？



#### 为什么Redis是单线程的却支持高并发？

- 纯内存操作，占用资源少，操作速度快。
- 基于非阻塞的IO多路复用机制。
- 单线程避免了多线程的频繁上下文切换问题。

#### 为什么Redis 是单线程的
- redis 所有的数据都在内存中，与其他数据库相比，少了磁盘$IO$的开销时间
- 多线程的系统中，不可避免地有线程调度，涉及到线程的上下文切换，这比较耗费时间
- 对于存在于内存的系统来说，没有上下文切换的时候效率最高。redis 将单线程绑定在指定$CPU$上完成。在内存系统中，这个是最佳的解决方案。
  > - 相比较于磁盘，内存的 $IOPS$ 非常高，对于一块内存，可以快速申请和销毁。而磁盘等介质的$IOPS$相对要低很多，但是磁盘的吞吐量大，因此可以将内存中的多次操作（如事务组）的数据，一次性从磁盘中读取或者写入。
  > - 默认情况下，单线程会被随机分配一个$CPU$内核，为了优化 redis，我们可以使用工具为其指定所运行的$CPU$。在$Linux$上，可以使用$taskset$工具，将某个进程绑定到某个$CPU$中，从而避免操作系统的调度器调度这个程序，避免调度带来的开销。
  >   redis 的瓶颈在于网络。

#### Redis 和 Memcached 的区别

| 对比参数     | Redis                                                        | Memcached                                                 |
| ------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| 类型         | 1. 支持内存；<br />2. 非关系型数据库                         | 1. 支持内存<br />2. key-value 键值对形式<br />3. 缓存系统 |
| 数据存储类型 | String，List，Set，Hash, Zset                                | 文本型，二级制类型                                        |
| 操作类型     | 1. 批量操作<br />2. 事务支持（**假事务**）<br />3. 每种类型不同的 CRUD | 1. CRUD<br />2. 少量的其他命令                            |
| 附加功能     | 1. 发布/订阅模式<br />2. 主从分区<br />3. 序列化支持<br />4. 脚本支持（LUA 脚本） | 多线程服务支持                                            |
| 网络$IO$模型 | 1. 单进程模式                                                | 多线程、非阻塞$IO$模式                                    |
| 事件库       | 自封装简易事件库 AeEvent                                     | LibEvent                                                  |
| 持久化支持   | RDB, AOF                                                     | 不支持                                                    |

#### 常用数据结构

##### 1. String

- 常用命令：set、get、decr、incr、mget 等。
- 简单的 key-value 类型，value 不仅可以是string，也可以是数字
- 应用：常规key-value应用；常规计数：微博数、粉丝数等。

##### 2. Hash

- 常用命令：hget，hset， hgetall 等。
- hash 是一个 string 类型的的 field 和 value 的映射表，hash 适于存储对象，后续操作的时候，可以直接仅仅修改这个对象的某个字段的值。
- 应用：存储用户信息、商品信息等。

##### 3. List

- 常用命令：lpush、rpush、lpop、rpop、lrange 等

- list 的实现为一个双向链表，既可以支持反向查找和遍历，更方便方便操作，不过会带来部分额外的内存开销。

- 应用：微博的关注链表，粉丝列表、消息列表等。

  > 可以通过 lrange 命令，从某个元素开始读多少个元素，可以基于 list 实现分页查询，基于 redis 实现简单的高性能分页。

##### 4. Set

- 常用命令：sadd、spop、smembers、sunio 等

- 功能于 list 类似，特殊之处在于可以自动排重。可以方便判断某个成员是否在一个 set 集合中。可以基于 Set 轻易实现交集、并集、差集。

- 应用：可以将一个用户从有的关注人存在一个集合中，见所有的粉丝存于一个集合。可以实现 共同关注、共同粉丝、共同爱好的等功能。也就是求交集的过程

  > sinterstore key1 key2 key3 将交集存于 key1 内

##### 5. Sorted Set

- 常用命令：zadd、zrange、zrem、zcard 等
- 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。
- 应用：在直播系统中，实时排行星系包含直播间在线用户列表，各种排行榜等。

#### Redis 设置过期时间

> Redis 有设置过期时间的功能。对于一个缓存数据库，这是非常实用的。不同于传统的数据库处理方式，一般都是自己判断过期时间，效率、性能低下。
>
> \> set page "www.baidu.com"
>
> \> expire page 30  # 设置过期时间30秒， -1 表示无限存活

##### Redis 是怎么删除 key 的

- 定期删除：redis 默认是每个 100ms 就**随机抽取**一些设置了过期时间的 key，检查其是否过期，如果过期则删除。

  ```
  从过期字典中随机 20 个 key；
  删除这 20 个 key 中已经过期的 key；
  如果过期的 key 比率超过 1/4，那就重复步骤 1
  ```

  > 随机删除的原因是如果 redis 存在几十万个 key， 如果每隔 100 ms就遍历这些 key，是非常浪费资源的。
  >
  > 为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。

  > 配置文件设置时间间隔：hz 10
  >
  > 提高它的值将会占用更多的cpu，当然相应的redis将会更快的处理同时到期的许多key，以及更精确的去处理超时。 hz的取值范围是1~500，通常不建议超过100，只有在请求延时非常低的情况下可以将值提升到100。

- 惰性删除：定期删除导致了很多过期的 key 到了时间并没有被删除掉。所以有了惰性删除。**惰性删除是当你的系统去查那个 key 时，如果 key 已经过期了，才会被 redis 删除。**

#### Redis 内存淘汰机制

> MySQL 里有 200w 条数据，Redis 只能存放 20W条数据，如何保证Redis中的数据都是热点数据
>
> redis 提供了 6 种数据淘汰策略

- volatile-lru：从已设置过期时间的数据集种挑选**最近最少使用**的数据淘汰
- volatile-ttl：从已设置过期时间的数据集中挑选**要过期**的数据淘汰
- volatile-random：从已设置过期时间的数据集中**任意选择**数据淘汰
- allkeys-lru: 当内存不足一容纳新写入的数据是，**在键空间中，移除最近最少使用**的key（*最常用）
- allkeys-random：从数据集中任意选择数据淘汰
- no-eviction：禁止驱逐数据，即当内存不足时，新写入操作会报错。

> 4.0 版本后增加一下两种

- volatile-lfu：从已设置过期时间的数据集中挑选**最不经常使用**的数据淘汰
- allkeys-lfu：当内存不足一容纳新写入的数据是，在键空间中，一处最不经常使用的 key



















































#### Redis 怎么知道要运行定时任务？

