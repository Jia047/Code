
[toc]

### 名词解释
#### 地址族
- 套接口在需要的时候创建，创建时主要需要指定的是域（domain），即所用的的地址族（AF_XXX，如AF_IRDA）。看 sockaddr 类型

#### 网络字节序
- 按从高到低的顺序存储，在网络上使用同一的网络字节顺序，可避免兼容性问题；
#### 主机字节序
- 网络字节序与主机字节序是经常导致混淆的两个概念，网络字节序是确定的，而主机字节序的多样性往往是混淆的原因。
#### 大端模式
- 指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这**和我们的阅读习惯一致**。
#### 小端模式
- 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
---
### 数据类型
#### size_t

- 与机器相关的unsigned类型，其大小足以确保存储内存中对象的大小
- size_t的全称应该是size type，就是说“一种用来记录大小的数据类型”。
- 通常我们用sizeof(XXX)操作，这个操作所得到的结果就是size_t类型。
#### intptr_t
- intptr_t是为了跨平台，其长度总是所在平台的位数，所以用来存放地址
- typedef long int        intptr_t;

#### stat
```c
struct stat
{
    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/
    ino_t       st_ino;     /* inode number -inode节点号*/
    mode_t      st_mode;    /* protection -保护模式?*/
    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/
    uid_t       st_uid;     /* user ID of owner -user id*/
    gid_t       st_gid;     /* group  ID of owner - group id*/
    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/
    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/
    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/
    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/
    time_t      st_atime;   /* time of last access -最近存取时间*/
    time_t      st_mtime;   /* time of last modification -最近修改时间*/
    time_t      st_ctime;   /* time of last status change - */
};
```
>文件（夹）信息的结构体，定义如下：以上信息就是可以通过_stat函数获取的所有相关信息，一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。

#### u_short

#### sockaddr_in
```c
struct sockaddr_in
{
    sa_family   sin_family;     // 地址族
    uint16_t    sin_port;       // 16位 TCP/UDP 端口号
    struct in_addr  sin_addr;   // 32位 IP 地址
    char        sin_zero[8];    // 不使用
};

struct sin_addr{
    In_addr_t   s_addr;     // 32 位 IPV4 地址
};
```
- sin_port 和 sin_addr 都必须是网络字节序，一般可视化的数字都是主机字节序
#### sockaddr
```c
struct sockaddr {
    sa_family_t sa_family;
    // 缺陷：sa_data把目标地址和端口信息混在一起
    char        sa_data[14];
}
```
- 该结构体的唯一目的是强制结构指针在addr参数中传送，以避免编译过程出现 waring
#### socklen_t

#### pthread_t
```c
    typedef struct {
        void * p;                   /* Pointer to actual object */
        unsigned int x;             /* Extra information - reuse count etc */
    } ptw32_handle_t;
    typedef ptw32_handle_t pthread_t;
```
- 一般用于声明线程ID


### 函数
#### socket();
- &lt;sys/socket.h&gt;
- int socket(int $domain$, int $type$, int $protocol$);
- 用来建立一个新的socket，也就是通知系统建立一个通信端口。
- 参数
    - domain：套接字通信域，指定使用何种的地址类型
        - AF_INET：IPv4 因特网域
        - AF_INET6：IPv6 因特网域
        - AF_UNIX：UNIX 域
        - AF_UPSPEC：未指定
    - type
        - SOCK_STREAM：提供双向连续且可信赖的数据流，即TCP，支持OOB机制，在所有数据传送前必须使用connect() 来建立连线状态
        - SOCK_DGRAM：使用不连续不可信赖的数据包连接
        - SOCK_SEQPACKET：提供连续可信赖的数据包连接
        - SOCK_RAM：提供原始网络协议存取
        - SOCK_RDM: 提供可信赖的数据包链接
        - SOCK_PACKET：提供和网络驱动程序直接通信
    - protocol：用来指定socket所使用的传输协议编号，通常此参数不用管它设为 0 即可。
- 成功则返回socket处理代码， 失败返回 -1，下列是错误代码
    - EPROTONOSUPPORT：参数domain指定的类型不支持参数 type
    - ENFILE：核心内存不足，无法建立新的socket结构
    - EMFILE：进程文件表溢出，无法在建立新的socket
    - EACCESS：权限不足，无法建立 type 或 protocol 指定的协议
    - ENOBUFS/ENOMEM：内存不足
    - EINVAL：参数 domain/type/protocol 不合法

#### memset()；
- void memset(void* $s$, int $c$, unsigned long $n$);
- 将指针变量s所指向的前 n 字节的内存单元用一个“整数” c 替换。因为 s 是 void* 型变量，所以它可以给任何类型的数据进行初始化。
- 作用是在一段内存中填充某个给定的值。可给变量初始化。
- 虽然参数 c 要求是一个整数，但是整型和字符型是互通的。但是赋值为 '\0' 和 0 是等价的，因为字符 '\0' 在内存中就是 0。所以在 memset 中初始化为 0 也具有结束标志符 '\0' 的作用，所以通常我们就写“0”。
```c
memset(str, 0, sizeof(str));
```

#### htons();
- unsigned short int htons(unsigned $short$, int $hostshort$);
- 将参数指定的 16 位 hostshort 转换成网络字节顺序
- "host to network short"
#### htonl();

- "host to network long"

#### setsockopt()
- int setsockopt(int s, int level, int optname, const void* optval, socklen_t optlen);
- 用来设置参数 s 所指定的socket状态。
- 参数 level 代表欲设置的网络层，一般设成 SOL_SOCKET以存储socket层，
- 参数optname 代表欲设置的选项
    - SO_DEBUG：打开或关闭排错模式
    - SO_REUSEADDR：允许在bind()过程中本地地址可重复使用
    - SO_TYPE：返回socket形态
    - SO_ERROR 返回socket 已发生的错误原因
    - SO_DONTROUTE：送出的数据包不要利用路由设备来传输
    - SO_BROADCAST：使用广播方式发送
    - SO_SNDBUF：设置送出的暂存区大小
    - SO_RCVBUF：设置接受的暂存区大小
    - SO_KEEPALIVE：定期确定连线是否已终止
    - SO_OOBINLINE：当接受到OOB数据时会马上送至标准输入设备。
    - SO_LINGER：确保数据安全且可靠地传送出去。
- 参数 optval 代表欲设置的值
- 参数 optlen 为 optval 的长度
- 返回值：成功返回0， 有错误则返回 -1， 错误原因存于 errno

#### bind();
- <sys/types.h>
- <sys/socket.h>
- int (int sockfd, const struct sockaddr * addr， socklen_t* addrlen);
- 当socket() 函数创建套接字后，套接字在名称空间中存在，但没有任何地址给他赋值。bind() 把用addr指定的地址赋值给用文件描述符代表的套接字 sockfd。addrlen 指定了以addr所指向的地址结构体的字节长度。
- 调用 bind() 函数后会给 socket() 函数创建的套接字关联一个相应的地址 addr，发送到这个地址的数据可以通过这个套接字读取与使用。
- 返回值：成功返回 0， 失败返回 -1，相应地设定全局变量 errno，错误码如下：
    - EACCESS：地址空间受保护，用户不具有超级用户的权限
    - EADDRINGUSE：给定的地址空间正在被使用
#### getsockname();
- <winsock.h>
- int getsockname(socket $s$, struct sockaddr * $name$, int $namelen$)
- s：标识一个已捆绑套接口的描述字
- name：接受套接口的地址
- namelen：名字缓冲区长度
- 返回值：若无错误发生，返回 0， 否则返回 SOCKET_ERROR 错误，应用程序可以通过WSAGetLastError() 获取像一个的错误代码
- 错误代码：
    - WSANOTINITIALISED：在使用此API之前应首先成功地调用 WSAStartup();
    - WSAENETDOWN：WINDOWS 套接口实现检测到网络子系统失效
    - WSAEFAULT：namelen 参数不够大
    - WSAEINPROGRESS：一个阻塞的 WINDOWS 套接字调用正在运行中。
    - WSAENOTSOCK：描述字不是一个套接口。
    - WSAEINVAL：套接口未用 bind() 捆绑。
#### ntohs();

#### listen();
- <sys/socket.h>
- int listen(int $sockfd$, int $backlog$);
- 将文件描述符 sockfd 引用的流 socket 标记为被动。这个 socket 后面会被用来接收来自其他（主动的）socket的连接。
- 无法在一个已连接的socket（即已成功执行 connect() 的socket或者由 accpet() 调用返回的socket）上执行listen()。
- 执行listen() 后套接字进入被动模式
- backlog：连接请求队列的最大长度。一般由2到4（因为服务器可能一下没办法解决那么多连接，所有有些连接需要等待）
- 返回值：无错误，返回 0；否则返回 SOCKET ERROR，windows上可以调用函数 WSAGetLastError 取得错误代码
#### accept();
- <sys/socket.h>
- int accept(int $sockfd$, struct sockaddr * $addr$, socklen_t* $addrlen$);
- 在文件描述符 sockfd 引用的监听流 socket 上接受一个接入连接。如果在accpet() 不存在为解决的连接，那么调用就会阻塞到直到有连接请求到达为止。
- sockfd：套接字描述符，该套接口在listen()后监听连接。指向一缓冲区，其中接收为通讯层所知的连接实体的地址。
- addr：指向了一个用来返回socket地址的结构。这个参数的类型取决于 socket domain。
- addrlen：整数，告诉内核有多少空间可用于返回socket地址。当accpet()返回后，这个整数会被设置成实际被复制进缓冲区的数据的字节数
#### close();
- <unistd.h>
- int close(int $fd$);
- 终止一个流 socket 连接
#### shutdown();
#### pthread_create();
- <pthread.h>
- int pthread_create(pthread_t *tidp, const pthread_attr_t * attr, (void*)(*start_rtn)(void*), void *arg);
- 在类Unix系统上创建线程的函数。
- 返回值：成功返回 0； 出错返回 -1。

#### send();
- <sys/socket.h>
- int send(int s, const void* msg, int len, unsigned int flags)
- 将数据有指定的 socket 传给对方主机
- flags 和 错误码参照 recv() 函数
#### revc();
- <sys/socket.h>
- int recv(int s, void* buf, int len, unsigned int flags);
- 用来接收远端主机京指定的socket传来的数据，并把数据存到由参数 buf 指向的内存空间。
- 参数len为可接受的数据的最大长度。
- 参数flag一般设置为 0， 其他数值定义如下
    - MSG_OOB：接受以out-of-band发送出的数据
    - MSG_PEEK：返回来的数据并不会在系统内删除，如果再调用recv()会返回相同的数据内容。
    - MSG_WATIALL：强迫接受到len大小的数据后才能返回，除非有错误或者信号产生
    - MSG_NOSIGNAL：此操作不愿被SIGPIPE信号中断
- 返回值：成功则返回接收到的字符数，失败返回 -1，错误存在于 errno中
- 错误代码
    - EBADF：参数 s 非合法的 socket 处理代码
    - EFAULT：参数中有一指针指向无法存取的内存空间
    - ENOTSOCK：参数 s 为以文件描述符，非 socket
    - EINTR：被信号所中断
    - EAGAIN：此动作会零进程阻断，单参数S的socket为不可阻断
    - ENOBUFS：系统的缓存内存不足
    - ENOMEM：核心内存不足
    - EINVAL：传给系统调用的参数不正确
#### isspace();
- <ctype.h>
- int isspace(int c);
- 判断输入字符是否为空格/回车/制表符等
- 获取实参char类型的字符
- 如果获取到的字符是空格/回车/制表符等，返回非0值（即真）；否则返回0。
#### strncasecmp();
- <string.h>
- int strncasecmp(const char* s1, const char *s2, size_t n);
- 比较字符串 s1、s2的前n个字符，比较时自动忽略大小写。

#### strcasecmp();
- <string.h>
- int strncasecmp(const char* s1, const char *s2);
- 比较字符串 s1、s2，比较时自动忽略大小写。

#### sprintf()
- <stdio.h>
- int sprintf(char* string_buffer, const char* format_string[,args]);
- 把格式化的数据写入某个字符串
- 转换字符

|转换字符| 作用|
| -- | -- |
| %% | 引出百分比号，不转换 |
| %c | 整数转成对应的 ASCII 字元 |
| %d | 整数转成十进位 |
| %f | 倍精确度数字转成浮点数 |
| %o | 整数转成八进制位 |
| %s | 整数转换成字符串 |
| %x | 整数转成小写十六进位 |
| %X | 整数转成大写十六进位 |

#### fgets();
- char* fgets(char* $str$, int $n$, FILE* $stream$);
- str：这是字符串读取存储的字符数组的指针
- n：这个最大的被读取的字符数（包括最后的空字符）。通常情况下，通过使用str是数组的长度
- stream：这是一个文件对象标识流中读取字符的指针
- 返回值：成功，返回str参数相同，如果遇到热河字符被读取完的文件，str的内容保持不变，并返回一个空指针；如果发生错误，则返回空指针
#### fopen();
- FILE* fopen(char* $filename$, char* $mode$)
- filename：文件名（包括文件路径）
- mode：打开方式
- 返回值：获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将改变量的地址返回

| 打开方式 | 意义 |
| -- | -- |
| r | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败 |
| w |以“写入”方式打开文件。如果文件不存在，那么创建一个恶心文件；如果文件存在，那么清空文件内容（相当于删除源文件，再创建一个新文件）|
| a |以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件以原有的内容保留）|
| r+ |以“读写”方式打开文件。就可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。|
| w+ |以“写入/更新”方式打开文件，相当于 w 和 r+ 叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么新创建一个文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）|
| a+ |以“追加/更新”方式打开文件，相当于 a 和 r+ 叠加的效果。即可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）|
> r(read)：读
w(write)：写
a(append)：追加
t(text)：文本文件
b(banary)：二进制文件
+：读和写

#### stat();
- int stat(const char* filename, struct stat* buf);
- 用来获取指定路径的文件或者文件夹的信息。
- filename：文件或者文件夹的路径
- buf：获取的信息保存在内存中
- 返回值：正确返回0； 错误返回 -1，具体错误码再errno中
### 常量
#### MSG_PEEK

#### S_IFMT

#### S_IFDIR

#### S_IXUSR

#### S_IXGRP

#### S_IXOTH

### 运算符
#### sizeof();
- [sizeof 解析](http://c.biancheng.net/cpp/html/932.html)
