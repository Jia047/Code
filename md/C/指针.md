
[toc]

### 常见异常
#### 访问数组和其他数据结构时越界
#### 自动变量消失后被引用
#### 堆上分配的内存释放后被引用
#### 内存分配之前解引指针

### 建议
1. 尽快初始化指针是一个好习惯。
    - $*$ 是一个重载过的符号，因为它也可以用在乘法和解引指针上。
2. 不要对NULL指针进行解引
3. 对于malloc()函数的返回值，做一个显示强制类型转换是个不错的做法
4. 为全局变量或者静态变量分配内存的语句，应该放在函数内部来执行，因为赋值语句这类代码必须出现在函数内部中。
```c
// 错误示例
static int * pi = (int*)malloc(sizeof(int));
int main(int argc, char const *argv[]) {
    // do somthing
    return 0;
}
```
5. 自己实现更安全的 free 函数
> 由于标准库中的free函数，会导致迷途指针的存在，所以在这里实现一个更安全的释放函数。其实质是释放后将指针指向 NULL
```c
void safer_free(void ** pp)
{
    if(pp != NULL && *pp != NULL)
    {
        free(*pp);
        *pp = NULL;
    }
}
// 使用safer_free宏，这样，函数使用者就不用做类型转换和传递指针的地址
#define safer_free(p) safer_free((void**)&(p))
```
6. 在函数指针的命名上，建议使用 “fptr” 作为前缀
7. 如果担心一个指针作为参数时，其指向的内容被修改，可以将形参定义为常量。如：
```c
int strlen(const char* string);
```

### 名词解释
#### 解引指针
- 间接引用操作符（$*$）返回指针变量指向的值

#### 内存泄漏
- 不再使用的已分配的内存却没有将其释放就会发生内存泄漏
    - 丢失内存地址
    - 应该调用free函数的地方没有调用（也叫隐式泄露）

#### NULL宏
- 是强制类型转换为void指针的整数常量0
```c
#define NULL ((void*)0)
```
#### void 指针
- void指针具有和char指针相同形式和内存的对齐方式
- void指针和别的指针永远不会相等，除非两个为NULL的void指针是相等的
- void指针只能用作数据指针，而不能用作函数指针
> 函数指针的长度是可变的

#### 迷途指针
- 内存已经释放，指针还指向原始内存地址
- 危害
    - 如果访问内存，则行为不可预期；
    - 如果内存不可访问，则发生段错误；
    - 潜在的安全隐患
### 指针相关的预定义类型
#### size_t
- 用于安全地表示长度
- 输出时使用的格式说明符：%zu, %u, %lu
#### ptrdiff_t
- 用于处理指针算数运算
#### intptr_t 和 uintptr_t
- 用于存储指针地址

### 操作符
#### sizeof
- sizeof 可以用来判断指针长度

### 内存操作函数
#### malloc
- void* malloc(size_t $len$);
- 参数为需要内存的大小，单位为字节数
- 为了管理malloc分配的内存，需要分配额外的内存$m$来管理这个内存块。所以一次malloc，分配的内存是$len+m$
#### realloc

#### calloc

#### free

### 指针和函数
> 局部变量也叫自动变量，其内存的分配发生在栈帧上。
> 栈帧的大小在程序编译的时候已经确定了
> C语言把块语句（如for循环)视为“微型”函数，会在适合的时机将其推入栈或从栈中弹出
#### 使用指针传递参数给函数
##### 好处
- 不用将实参声明为全局变量便可以对实参进行数据操作
- 避免了在实参与形参之间的数据拷贝
- 避免栈帧因参数大小原因占用太大的内存
#### 传递指向常量的指针
#### 函数返回指针
##### 潜在的问题
- 返回未初始化的指针
- 返回无效地址的指针
- 返回局部变量的指针
- 返回指针但是没有释放内存

#### 函数指针
##### 声明函数指针
- 示例
    ```c
    // void 是函数的返回值类型
    // func 是函数名
    // params 是函数的参数
    void (*func)(params);


    // fun1 是一个函数，返回int类型。 写成 int* fun1(); 会更容易看出来
    int *fun1();
    // fun2 是一个函数指针，返回整数
    int (*fun2)();
    // fun3 是一个函数指针，返回整数类型的地址
    int* (*fun3)();
    ```
    > C 语言不会检查函数指针的参数传递是否正确
##### 使用函数指针
- 示例
    ```c
    // 定义一个 square 函数，返回一个整数的平方值
    int square(int num)
    {
        return num * num;
    }

    // 声明一个函数指针
    int (*fptr)(int);
    // 将square的函数地址赋给函数指针
    fptr = square;
    num = 2;
    printf("%d squared is %d\n", num, fptr(num));
    ```
> 为函数声明一个类型定义,如此一来，我们可以直接用 ftpr 来直接声明一个函数指针
> ```c
> typedef int (*fptr)(int);
> fptr fp;
> fp = suqare;
> ```
##### 函数指针做参数
- 示例
    ```c
    // 两数相加
    int add(int n1, int n2)
    {
        return n1 + n2;
    }
    // 两数相减
    int sub(int n1, int n2)
    {
        return n1 - n2;
    }
    typedef int (*fptrOperation)(int, int);

    int compute(fptrOperation operation, int n1, int n2)
    {
        return operation(n1, n2);
    }

    printf("%d\n", compute(add, 5, 6)); // 结果是 11
    printf("%d\n", compute(sub, 5, 6)); // 结果是 -1
    ```
##### 函数指针作为返回值
- 示例
    ```c
    fptrOperation select(char op_code)
    {
        switch (op_code) {
            case '+': return add;
            case '-': return sub;
        }
    }

    printf("%d\n", select('+', 5, 6)); // 结果是 11
    printf("%d\n", select('-', 5, 6)); // 结果是 -1
    ```
##### 使用函数指针数组
- 示例
    ```c
    typedef int (*operation)(int, int);

    operation operations[128] = {NULL};

    // 初始化操作数组
    void init_operation_array()
    {
        operations['+'] = add;
        operations['-'] = sub;
    }
    int evaluate_array(char op_code, int n1, int n2)
    {
        fptrOperation operation;
        operation = operations[op_code];
        return operation(n1, n2);
    }
    printf("%d\n", evaluate_array('+', 5, 6)); // 结果是 11
    printf("%d\n", evaluate_array('-', 5, 6)); // 结果是 -1
    ```
### 指针和数组

### 指针和字符串
#### 单字节字符串、宽字符串
- 单字节字符串：由char类型的字符组成的序列
- 宽字符串：由 wchar_t 数据类型组成的序列
> wchar_t 数据类型用来表示宽字符，要么是16位，要么是32位。wchar_t 主要用来支持非拉丁字符集。
```c
printf("%d\n", sizeof(char)); // 1 字节
printf("%d\n", sizeof('a')); // 4 字节
```
#### 字符串声明方式
##### 字面量
- 使用双引号引起来的字符序列，常用来进行初始化，他们位于字符串字面量池中。
##### char数组
- 声明一个字符数组，指定其长度为$len$，则可以存放 $len-1$ 个字符，因为字符串需要用 '\0' 结尾，'\0' 占一个字符。
##### char指针
- 形如 char* cp, 其长度和内容是未定的。
#### 函数指针和字符串
> 使用函数指针，将比较函数作为参数，让排序函数按照自定义的比较大小的规则来排序。
```c
typedef int (*fptrOperation)(const char*, const char*);

int compare(const char* s1, const, char* s2)
{
    return strcmp(s1, s2);
}

void sort(const char* array[], int size, fptrOperation operation)
{
    // 在排序过程中，如果需要比较array中每个字符串的大小，则使用
    // if(operation(s1, s2) > 0) ，若为 true， 则s1 > s2
}

int main(int argc, char const *argv[]) {
    char names[5] = {"abc", "ABC"};
    sort(names, sizeof(names) / sizeof(char), compare);
    // 打印 names
    return 0;
}
```
### 指针和结构体
#### 为结构体分配内存
- 为结构体分配内存时，分配的内存大小至少是各个字段的长度和。不过，实际中通常会大于这个和，因为内部的字段之间可能会由填充。某些数据要对其到某个边界就需要填充。比如说，短整数通常要对齐到能被2整除的地址上；整数通常要对齐到能被4整除的地址上。
#### 结构体释放问题
- 如果结构体内部字段存在指针，那么在释放结构体时，系统不会释放内部指针指向的内存，需要调用者自己去释放。

#### 避免频繁使用malloc和free，使用结构体池
- 重复地分配和释放结构体会造成一定的开销。可以像创建线程池一般创建一个结构体池。
