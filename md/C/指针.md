
[toc]

### 常见异常
#### 访问数组和其他数据结构时越界
#### 自动变量消失后被引用
#### 堆上分配的内存释放后被引用
#### 内存分配之前解引指针

### 建议
1. 尽快初始化指针是一个好习惯。
    - $*$ 是一个重载过的符号，因为它也可以用在乘法和解引指针上。
2. 不要对NULL指针进行解引
3. 对于malloc()函数的返回值，做一个显示强制类型转换是个不错的做法
4. 为全局变量或者静态变量分配内存的语句，应该放在函数内部来执行，因为赋值语句这类代码必须出现在函数内部中。
```c
// 错误示例
static int * pi = (int*)malloc(sizeof(int));
int main(int argc, char const *argv[]) {
    // do somthing
    return 0;
}
```
5. 自己实现更安全的 free 函数
> 由于标准库中的free函数，会导致迷途指针的存在，所以在这里实现一个更安全的释放函数。其实质是释放后将指针指向 NULL
```c
void safer_free(void ** pp)
{
    if(pp != NULL && *pp != NULL)
    {
        free(*pp);
    }
    *pp = NULL;
}
// 使用safer_free宏，这样，函数使用者就不用做类型转换和传递指针的地址
#define safer_free(p) safer_free((void**)&(p))
```
### 名词解释
#### 解引指针
- 间接引用操作符（$*$）返回指针变量指向的值

#### 内存泄漏
- 不再使用的已分配的内存却没有将其释放就会发生内存泄漏
    - 丢失内存地址
    - 应该调用free函数的地方没有调用（也叫隐式泄露）

#### NULL宏
- 是强制类型转换为void指针的整数常量0
```c
#define NULL ((void*)0)
```
#### void 指针
- void指针具有和char指针相同形式和内存的对齐方式
- void指针和别的指针永远不会相等，除非两个为NULL的void指针是相等的
- void指针只能用作数据指针，而不能用作函数指针
> 函数指针的长度是可变的

#### 迷途指针
- 内存已经释放，指针还指向原始内存地址
- 危害
    - 如果访问内存，则行为不可预期；
    - 如果内存不可访问，则发生段错误；
    - 潜在的安全隐患
### 指针相关的预定义类型
#### size_t
- 用于安全地表示长度
- 输出时使用的格式说明符：%zu, %u, %lu
#### ptrdiff_t
- 用于处理指针算数运算
#### intptr_t 和 uintptr_t
- 用于存储指针地址

### 操作符
#### sizeof
- sizeof 可以用来判断指针长度

### 内存操作函数
#### malloc
- void* malloc(size_t $len$);
- 参数为需要内存的大小，单位为字节数
- 为了管理malloc分配的内存，需要分配额外的内存$m$来管理这个内存块。所以一次malloc，分配的内存是$len+m$
#### realloc

#### calloc

#### free

### 指针和函数
> 局部变量也叫自动变量，其内存的分配发生在栈帧上。
> 栈帧的大小在程序编译的时候已经确定了
> C语言把块语句（如for循环)视为“微型”函数，会在适合的时机将其推入栈或从栈中弹出
#### 使用指针传递参数给函数
- 好处
    - 不用将实参声明为全局变量便可以对实参进行数据操作
    - 避免了在实参与形参之间的数据拷贝
    - 避免栈帧因参数大小原因占用太大的内存
#### 传递指向常量的指针
#### 函数返回指针
- 潜在的问题
    - 返回未初始化的指针
    - 返回无效地址的指针
    - 返回局部变量的指针
    - 返回指针但是没有释放内存
