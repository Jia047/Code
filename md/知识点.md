

1. ##### Spring 获取Bean的方式

2. ##### 使用 EntityManger 完成自定义查询

3. ##### Java基本类型对应的Hibernate类型

   ```java
   private static final class TypeMap{
           /**
            * Java 类型与 hibernate 类型的映射
            */
           private static final Map<Class, Type> TYPE_MAP;
   
           static{
               TYPE_MAP = new HashMap<>();
               TYPE_MAP.put(Boolean.class, StandardBasicTypes.BOOLEAN);
               TYPE_MAP.put(Byte.class, StandardBasicTypes.BYTE);
               TYPE_MAP.put(Short.class, StandardBasicTypes.SHORT);
               TYPE_MAP.put(Integer.class, StandardBasicTypes.INTEGER);
               TYPE_MAP.put(Long.class, StandardBasicTypes.LONG);
               TYPE_MAP.put(Float.class, StandardBasicTypes.FLOAT);
               TYPE_MAP.put(Double.class, StandardBasicTypes.DOUBLE);
               TYPE_MAP.put(BigInteger.class, StandardBasicTypes.BIG_INTEGER);
               TYPE_MAP.put(BigDecimal.class, StandardBasicTypes.BIG_DECIMAL);
               TYPE_MAP.put(Character.class, StandardBasicTypes.CHARACTER);
               TYPE_MAP.put(String.class, StandardBasicTypes.STRING);
               TYPE_MAP.put(Date.class, StandardBasicTypes.DATE);
               TYPE_MAP.put(Time.class, StandardBasicTypes.TIME);
               TYPE_MAP.put(Timestamp.class, StandardBasicTypes.TIMESTAMP);
               TYPE_MAP.put(Calendar.class, StandardBasicTypes.CALENDAR);
               TYPE_MAP.put(TimeZone.class, StandardBasicTypes.TIMEZONE);
               TYPE_MAP.put(LocalDate.class, LocalDateType.INSTANCE);
               TYPE_MAP.put(LocalTime.class, LocalTimeType.INSTANCE);
               TYPE_MAP.put(LocalDateTime.class, LocalDateTimeType.INSTANCE);
               TYPE_MAP.put(Locale.class, StandardBasicTypes.LOCALE);
               TYPE_MAP.put(Currency.class, StandardBasicTypes.CURRENCY);
           }
       }
   ```

   

4. ##### 对时间返回值进行格式化

   ```
   @JsonFormat(timezone = "Asia/Shanghai", pattern = "yyyy-MM-dd HH:mm:ss")
   ```

5. ```
   org.springframework.dao.InvalidDataAccessResourceUsageException: Ordinal parameter not bound : 1;
   参数没设置进去
   ```

6. ##### 验证反射跟直接调用的性能差别

   ```
   反射大概比直接调用慢50~100倍，但是需要你在执行100万遍的时候才会有所感觉
   判断一个函数的性能，你需要把这个函数执行100万遍甚至1000万遍
   如果你只是偶尔调用一下反射，请忘记反射带来的性能影响
   如果你需要大量调用反射，请考虑缓存。
   你的编程的思想才是限制你程序性能的最主要的因素
   ```

7. ##### 反射结果缓存

8. ##### 通用的jpa查询模板

9. ##### 取出非空字段

10. ##### 防止重复提交

11. ##### 构造器与类的继承