### 权限拦截
Shiro和SpringSecurity相同的是，shiro在做全新啊拦截是也是基于拦截器链和一些拦截器的。
Shiro使用了与Servlet一样的Filter接口进行拓展
![](https://note.youdao.com/yws/api/personal/file/WEB09fe6e37a6adfb6720ba1dc4a032a8d2?method=download&shareKey=a4d8a25eb782a0c06975e9e6f95c0c47)
#### NameableFilter
- 其实就是给Filter起了个名字，如果没有设置，默认就是FilterName,当我们组装拦截器链时，会根据这个名字找到相应的拦截器实例
#### OncePerRequestFilter
- 主要用来防止多次执行Filter的，也就是一次请求指挥走一次拦截器链
- 提供了Enable属性，表示是否开启该拦截器实例，默认是开启，如果不想某个拦截器工作，可以设置为false即可
#### ShiroFilter
- 它是整个shiro的入口点，用于拦截需要安全控制的请求进行处理
#### AdviceFilter
```java
// 类似于AOP中的前置增强，在拦截器链执行之前执行，
// 如果返回true，则表示继续拦截链，否则终端后续的拦截器链执行，直接返回
boolean preHandle(ServletRequest request, ServletResponse response) throws Exception

//  类似于AOP中的后置返回增强，在拦截器链执行之后执行，进行后处理，比如记录执行时间等
void postHandle(ServletRequest request, ServletResponse response) throws Exception

// 类似与AOP中的后置最终增强，即不服按有没有异常都会执行，可以进行清理资源
void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception;
```

#### PathMatchingFilter
- 提供一套基于Ant风格的请求路径匹配功能，以及拦截器的参数解析功能
```java
// 该方法用于path与请求路径进行匹配的方法，如果匹配返回true
boolean pathsMatch(String path, ServletRequest request)

// 在preHandle中，当pathMatch匹配一个路径后，会调用opOreHandle
// 方法并将路径绑定参数配置传给mappedValue;然后可以在这个方法中进
// 行一些验证，如角色授权；如果验证失败，返回false终端流程；如果返
// 回true，也就是说子类可以只实现onpreHandle即可，无需实现preHandle。
// 如果没有path与路径匹配，默认是通过的
boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception
```
#### AccessControlFilter
- AccessControlFilter提供了访问控制的基础功能，比如是否允许访问/当拒绝访问是如何处理等。
```java
// 表示允许访问，mappedValue就是[urls]中的拦截器参数部分，如果允许访问返回true，否则返回false
abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;

// 表示当访问拒绝时是否已经处理了；如果返回true表示需要继续处理；如果返回false表示该拦截器已经处理，将直接返回即可
boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;
```
#### ProxiedFilterChain-拦截器链
- Shiro对Servlet容器的FilterChain进行代理，即ShiroFilter在继续Servlet容器的Filter链的执行之前，通过ProxiedFilterChain对Servlet容器的FilterChain进行代理；即先走Shiro自己的Filter体系，然后才会委托给Servlet容器的FilterChain进行Sevelet容器级别的Filter链执行。
- Shiro的ProxiedFilterChain执行流程
    1. 先执行Shiro自己的Filter链
    2. 再执行Servlet容器的Filter链
- ProxiedFilterChain是通过FilterChainResolver根据配置文件中[urls]部分是否与请求的URL是否匹配解析得到的。
