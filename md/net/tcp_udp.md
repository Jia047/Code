| 区别       | TCP    | UDP                    |
| ---------- | ------ | ---------------------- |
| 面向对象   | 字节流 | 数据报                 |
| 可靠性     | 可靠   | 不可靠                 |
| 丢包现象   | 不会   | 会                     |
| 数据顺序性 | 保证   | 不保证                 |
| 支持模式   | 一对一 | 一对一，一对多，多对多 |
| 数据边界   | 无边界 | 有边界                 |
| 首部       | 20字节 | 8字节                  |
| 效率       | 较低   | 高                     |
| 报文结构   | 复杂   | 较简单                 |

TCP拥塞控制：慢开始、拥塞避免；快开始、快恢复。通过拥塞窗口实现。
UDP没有拥塞控制，故不会收到网络拥堵的影响，适合实时性高的应用。

- 提供可靠性
    - 将数据截断为合理长度（将应用层的数据切分为多个适合发送的TCP数据长度）
    - 超时重传。（数据包发送出去后，会启动一个定时器，等待目的端口发回确认信息，如果不能及时收到确认，那么会重新发送这个报文段）
    - 确认机制。当TCP收到另一端的TCP数据时会发回一个确认包。
    - 数据校验。首部设置了校验和字段，接收端收到数据之后，算出校验和，与首部的校验和比较，如果不一致，将丢弃该包。
    - TCP接收数据之后，会排好顺序，然后才提交给应用层。
    - 对于重复的数据，能够丢弃。
    - 提供流量控制。收发双方都有一个固定大小的缓冲空间。采用滑动窗口协议。

UDP的优势
- 简单、传输快。
- 网络的提升给UDP的稳定性提供了可靠的保障，丢包率很低，如果在应用层使用丢包重传，就可以确保传输的稳定性。
- 没有像TCP那样繁琐的握手过程和复杂的拥塞控制。
- 对于TCP，如果发生丢包，那么在丢包重传并被接收到的这段时间内，后面来的包都会被缓存起来，导致延时加重。

拥塞控制
- 慢开始：设置慢开始门限（sshresh），滑动窗口（cwind）为1，每经过一个RTT,cwind大小增加一倍。
- 拥塞避免：当cwind >= sshresh 时，采用拥塞避免算法，每经过一个RTT，cwind加一。
- 当增长到出现网络拥塞时，sshresh 减小为原来的一般，cwind减为1。
- 快重传：当收到接收方发送的失序报文段失，便对最后一个有序报文段进行确认。当次数达到3次时，要尽快重传未被确认的报文。
- 快恢复：快重传后，sshresh减半，cwind设置为sshresh，并呈线性增长。
- MAX_发送窗口 = MIN[rwind, cwind] （rwind为接受窗口）

TCP三次握手
> 假设有主机A和B，一开始二者都是处于CLOSED状态。
1. 主机A向主机B发送一个请求同步的数据包并将数据包的首部中的**SYN字段置为1**，生成一个**随机数**作为**序列号seq=x**。发送之后A进入同步发送状态**SYN_SENT**。
2. 如果此时B对应的端口处于LISTEN状态，在接受到A的同步请求后，**B向A发送一个确认包**，将**SYN、ACK字段置为1**，生成**随机数**作为序列号**seq=y, ack=x+1**，B进入同步接收状态**SYN_RECVD**。
3. A接收到B的确认包后，**再向B发送确认包**，**将ACK置为1**，**seq=x+1, ack=y+1**，然后**A进入连接建立状态ESTABLISHED**。**B**在接收到A的确认包后，**也进入ESTABLISHED状态**。
![](https://note.youdao.com/yws/api/personal/file/WEB3e9157815f27ed43eca7846d8725f13d?method=download&shareKey=ccb9931de239322130ce5bb44d336134)

TCP四次挥手
> 假设有主机A和B，一开始二者都是处于ESTABLISHED状态。
1. 主机A向主机B发送一个终止连接的包，置FIN为1，并生成一个随机数作为序列号seq=v。发送之后A进入终止等待状态FIN_WAIT_1。
2. 主机B接收到FIN包后，通知应用层程序，同时发送确认包，将ACK置为1,生成随机数最为序列号seq=v,ack=u+1，，B进入CLOSE_WAIT状态。
3. 主机A收到确认包后，不发送确认包，状态变更为FIN_WAIT_2
4. 主机B收到应用层可以关闭的通知后，发送第二个确认包，置FIN,ACK字段为1，seq=w,ack=u+1，B进入LAST_ACK状态
5. A收到第二个确认包后，马上发送确认包，置ACK=1, seq=u+1, ack=w+1，然后等待 2MSL 时间，期间处于TIME_WAIT状态，过了时间后变为CLOSED状态。
6. B收到确认包后，进入CLOSED 状态。
![](https://note.youdao.com/yws/api/personal/file/WEB08843b03ccc709b634ea086be91e7909?method=download&shareKey=9fe1653817e0dd42603df26d671a01e7)

为什么是三次握手而不是两次？
如果细心点就会发现，单靠前两次握手，主动连接的A是不知道B的序列号seq的。而序列号在可靠传输是起着重要作用的，所以需要三次握手。
https://blog.csdn.net/lengxiao1993/article/details/82771768

为什么四次挥手的时候要等 2MLS ?
1. 假设主动方发送确认包后马上关闭连接，如果这个确认包丢失了，那么被动方将会一直等待主动方而导致资源浪费。因为我们没有马上关闭连接，当被动方长时间没收到确认包时，主动方可以重发确认包。
2. 
